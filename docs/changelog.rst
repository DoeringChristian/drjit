.. py:module:: drjit

.. _changelog:

Changelog
#########

DrJit 1.0.0 (TBA)
-----------------

Dr.Jit 1.0 represents a major redesign of many parts of this project. The
following list covers the most important changes and their impact on
source-level compatibility. Points with an exclamation sign cover
incompatibilities and potential stumbling blocks.

- ⚠️ Dr.Jit comes with an all-new set of Python bindings created using the
  `nanobind <https://github.com/wjakob/nanobind>`__ library. This was also an
  opportunity to fix many long-standing binding-related problems:

  - Tracing Dr.Jit code written in Python is now *significantly* faster. Expect
    speedups of ~10-20×. The shared libraries containing the bindings have also
    become much smaller (from ~10MB to just over ~1MB).

  - All functions now have a reference documentation that clearly specifies
    their behavior and accepted inputs. Their behavior with respect to less
    common inputs (tensors, :ref:`Pytrees <pytrees>`) was made consistent
    and documented across the codebase.

  - Due to the magnitude of these changes, you may observe occasional
    incompatibilities. If they are not reported here, please open a ticket so
    that they can either be documented (if intentional) or fixed.

- ⚠️ The ``==`` and ``!=`` comparisons previously reduced the result of to a
  single Python ``bool``. They now return an array of component-wise
  comparisons. Use :py:func:`dr.all(a == b) <all>` or :py:func:`dr.all(a == b,
  axis=None) <all>` to reproduce the previous behavior.

  This change makes Dr.Jit more consistent with other array programming
  frameworks. The functions ``drjit.eq()`` and ``drjit.neq()`` for element-wise
  equality and inequality tests were removed, as their behavior is now subsumed
  by the builtin ``==`` and ``!=`` operators.

- ⚠️ The Dr.Jit matrix type switched from column-major to row-major storage.
  Your code will need to be updated if it indexes into matrices first by column
  and then row (``matrix[col][row]``) instead of specifying the complete
  location ``matrix[row, col]``. The latter convention is consistent between
  both versions.

- **Mixed-precision optimization**: Dr.Jit now maintains one global AD graph
  for all variables, enabling differentiation of computation combining single-,
  double, and half precision variables. Previously, there was a separate graph
  per type, and gradients did not propagate through casts between them.

- Variable indices (:py:attr:`drjit.ArrayBase.index`,
  :py:attr:`drjit.ArrayBase.index_ad`) used to monotonically increase as
  variables were being created. Internally, multiple hash tables were needed to
  associate these ever-growing indices with locations in an internal variable
  array, which which had a surprisingly large impact on tracing performance.
  Dr.Jit removes this mapping both at the AD and JIT levels and eagerly reuses
  variable indices.

  This change can be inconvenient for low-level debugging, where it was often
  helpful to inspect the history of operations involving a particular variable
  by searching a trace dump for mentions of its variable index. Such trace dumps
  were generated by setting :py:func:`drjit.set_log_level` to a level of
  :py:attr:`drjit.LogLevel.Debug` or even :py:attr:`drjit.LogLevel.Trace`. A
  new flag was introduced to completely disable variable reuse and help such
  debugging workflows:

  .. code-block:: python

     dr.set_flag(dr.JitFlag.IndexReuse, False)

  Note that this causes the internal variable array to steadily grow, hence
  this feature should only be used for brief debugging sessions.

- Reductions operations previously existed as *ordinary* (e.g.,
  :py:func:`drjit.all`) and *nested* (e.g. ``drjit.all_nested``) variants. Both
  are now subsumed by an optional ``axis`` argument similar to how this works
  in other array programming frameworks like NumPy.

  The reduction functions (:py:func:`drjit.all` :py:func:`drjit.any`,
  :py:func:`drjit.sum`, :py:func:`drjit.prod`, :py:func:`drjit.min`,
  :py:func:`drjit.max`) reduce over the outermost axis (``axis=0``) by default,
  Specify ``axis=None`` to reduce the entire array recursively analogous to the
  previous nested reduction.

  Aliases for the ``_nested`` function variants still exist to facilitate
  porting but are deprecated and will be removed in a future release.

- The new release has a strong focus on error resilience and leak avoidance.
  Exceptions raised in custom operations, virtual function dispatch, recorded
  loops, etc., should not cause leaks. Both Dr.Jit and nanobind are very noisy
  if they detect that objects are still alive when the Python interpreter shuts
  down. You may occasionally still see such leak warnings.

- Dr.Jit can now target the Python 3.12+ stable ABI. This means that binary
  wheels will work on future versions of Python without recompilation.

Internals
---------

This section documents lower level changes that don't directly impact the
Python API.

- Dr.Jit now compiles a support library (``libdrjit-extra.so``) containing
  large amounts of functionality that used to be implemented using templates.
  The template-heavy approach had the disadvantage that this code was compiled
  over and over again when Dr.Jit was used within larger projects such as
  `Mitsuba 3 <https://mitsuba-renderer.org>`__. The following features were
  moved into this library:

  * Transcendental functions (:py:func:`drjit.log`, :py:func:`drjit.atan2`,
    etc.) now have pre-compiled implementations for Jit arrays. Automatic
    differentiation of such operations was also moved into
    ``libdrjit-extra.so``.

  * The AD layer was rewritten to reduce the previous
    backend (``drjit/include/autodiff.h``) into a thin wrapper around
    functionality in ``libdrjit-extra.so``. The previous AD-related shared
    library ``libdrjit-autodiff.so`` no longer exists.

  * Virtual function dispatch (``drjit/include/vcall.h``,
    ``drjit/include/vcall_autodiff.h``, ``drjit/include/vcall_jit_reduce.h``,
    ``drjit/include/vcall_jit_record.h``) was turned into generic
    implementation reachable through a single function call in the
    ``libdrjit-extra.so`` library, which supports wavefront/recorded mode along
    with automatic differentiation.

- The packet mode backend (``include/drjit/packet.h``) now includes support
  for ``aarch64`` processors via NEON intrinsics. This is actually an old
  feature from a predecessor project (Enoki) that was finally revived.


Removals
--------

- Packet-mode virtual function code dispatch
  (``drjit/include/vcall_packet.h``) was removed.

- The ability to instantiate a differentiable array on top of a
  non-JIT-compiled type (e.g., ``dr::DiffArray<float>``) was removed. This was
  in any case too inefficient to be useful besides debugging.

